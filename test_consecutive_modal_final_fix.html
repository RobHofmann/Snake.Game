<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consecutive Modal Fix - Final Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }

        h1 {
            text-align: center;
            color: #4deed4;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }

        .status.success { background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71; }
        .status.error { background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; }
        .status.info { background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; }
        .status.warning { background: rgba(243, 156, 18, 0.2); border: 1px solid #f39c12; }

        .test-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .test-button {
            background: linear-gradient(45deg, #4deed4, #3498db);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(77, 238, 212, 0.3);
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(77, 238, 212, 0.4);
        }

        .test-button:active {
            transform: translateY(0);
        }

        .test-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .game-frame {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .debug-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .console-output {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .flag-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .flag-true { color: #2ecc71; font-weight: bold; }
        .flag-false { color: #e74c3c; font-weight: bold; }
        .flag-number { color: #f39c12; font-weight: bold; }

        iframe {
            width: 100%;
            height: 500px;
            border: none;
            border-radius: 8px;
            background: white;
        }

        .test-results {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .game-cycle {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            border-left: 4px solid #4deed4;
        }

        .cycle-success { border-left-color: #2ecc71; }
        .cycle-failed { border-left-color: #e74c3c; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Consecutive Modal Fix - Final Test</h1>
        <p style="text-align: center; font-size: 18px; color: #4deed4;">
            Testing the race condition fix for consecutive game modals
        </p>

        <div id="status" class="status info">
            Ready to test consecutive modal fix...
        </div>

        <div class="test-controls">
            <button class="test-button" onclick="loadGame()">üéÆ Load Game</button>
            <button class="test-button" onclick="testSingleModal()">üß™ Test Single Modal</button>
            <button class="test-button" onclick="testConsecutiveModals()">üîÑ Test Consecutive Modals</button>
            <button class="test-button" onclick="checkFlags()">üîç Check Flags</button>
            <button class="test-button" onclick="clearConsole()">üßπ Clear Console</button>
            <button class="test-button" onclick="analyzeRaceCondition()">üî¨ Analyze Race Condition</button>
        </div>

        <div class="test-area">
            <div class="game-frame">
                <h3>üéÆ Game Frame</h3>
                <iframe id="game-iframe" src="about:blank"></iframe>
            </div>

            <div class="debug-panel">
                <h3>üîç Debug Panel</h3>
                <div class="flag-display" id="flag-display">
                    Flags will appear here after loading game...
                </div>
                <div class="console-output" id="console-output">
                    Console output will appear here...
                </div>
            </div>
        </div>

        <div class="test-results" id="test-results" style="display: none;">
            <h3>üìä Test Results</h3>
            <div id="results-content"></div>
        </div>
    </div>

    <script>
        let gameWindow = null;
        let consoleDiv = document.getElementById('console-output');
        let flagDiv = document.getElementById('flag-display');
        let statusDiv = document.getElementById('status');
        let testResults = [];

        function updateStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'success' ? '#2ecc71' : type === 'error' ? '#e74c3c' : type === 'warning' ? '#f39c12' : '#ffffff';
            consoleDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            console.log(message);
        }

        function clearConsole() {
            consoleDiv.innerHTML = '';
        }

        function updateFlags() {
            if (!gameWindow) {
                flagDiv.innerHTML = '<span style="color: #e74c3c;">Game not loaded</span>';
                return;
            }

            try {
                const flags = {
                    gameState: gameWindow.gameState,
                    score: gameWindow.score,
                    gameStartTime: gameWindow.gameStartTime,
                    gameWasPlayed: gameWindow.gameWasPlayed,
                    scoreSubmitted: gameWindow.scoreSubmitted,
                    pageLoadTime: gameWindow.pageLoadTime,
                    readyStateActive: gameWindow.readyStateActive
                };

                let html = '<strong>üèÅ Current Flags:</strong><br>';
                for (const [key, value] of Object.entries(flags)) {
                    let className = 'flag-number';
                    if (typeof value === 'boolean') {
                        className = value ? 'flag-true' : 'flag-false';
                    }
                    html += `<span class="${className}">${key}: ${value}</span><br>`;
                }

                // Add timing calculations
                if (gameWindow.pageLoadTime) {
                    const timeSincePageLoad = Date.now() - gameWindow.pageLoadTime;
                    html += `<span class="flag-number">timeSincePageLoad: ${timeSincePageLoad}ms</span><br>`;
                }
                
                if (gameWindow.gameStartTime > 0) {
                    const timeSinceGameStart = Date.now() - gameWindow.gameStartTime;
                    html += `<span class="flag-number">timeSinceGameStart: ${timeSinceGameStart}ms</span><br>`;
                }

                flagDiv.innerHTML = html;
            } catch (error) {
                flagDiv.innerHTML = `<span style="color: #e74c3c;">Error reading flags: ${error.message}</span>`;
            }
        }

        function loadGame() {
            log('üéÆ Loading Snake game with consecutive modal fix...');
            updateStatus('Loading game...', 'info');
            
            const iframe = document.getElementById('game-iframe');
            iframe.src = 'http://localhost:5080';
            
            iframe.onload = function() {
                gameWindow = this.contentWindow;
                log('‚úÖ Game loaded successfully', 'success');
                updateStatus('Game loaded! Ready for consecutive modal testing.', 'success');
                
                // Start monitoring flags
                setInterval(updateFlags, 1000);
                updateFlags();
            };
            
            iframe.onerror = function() {
                log('‚ùå Failed to load game', 'error');
                updateStatus('Failed to load game. Make sure server is running on port 5080.', 'error');
            };
        }

        function checkFlags() {
            if (!gameWindow) {
                updateStatus('Game not loaded yet!', 'error');
                return;
            }

            log('üîç MANUAL FLAG CHECK:');
            updateFlags();
            updateStatus('Flag check completed - see debug panel', 'success');
        }

        function testSingleModal() {
            if (!gameWindow) {
                updateStatus('Game not loaded! Click "Load Game" first.', 'error');
                return;
            }

            log('üß™ TESTING SINGLE MODAL:');
            updateStatus('Testing single modal...', 'info');

            try {
                // Reset to Ready state first
                gameWindow.gameState = 'Ready';
                gameWindow.updateUI();
                log('1Ô∏è‚É£ Reset to Ready state');
                updateFlags();

                // Set up game conditions
                gameWindow.gameState = 'Playing';
                gameWindow.score = 150;
                gameWindow.gameStartTime = Date.now() - 10000;
                gameWindow.gameWasPlayed = true;
                gameWindow.scoreSubmitted = false;
                gameWindow.pageLoadTime = Date.now() - 30000;
                
                log('2Ô∏è‚É£ Set up playing state with score 150');
                updateFlags();

                // End game
                gameWindow.gameState = 'GameOver';
                gameWindow.updateUI();
                log('3Ô∏è‚É£ Game ended, calling updateUI()');

                // Check modal
                setTimeout(() => {
                    const modal = gameWindow.document.getElementById('nameInputModal');
                    const isVisible = modal && !modal.classList.contains('hide');
                    
                    log(`üìä SINGLE MODAL RESULT: Modal visible = ${isVisible}`);
                    
                    if (isVisible) {
                        log('‚úÖ SUCCESS: Single modal test passed!', 'success');
                        updateStatus('Single modal test PASSED', 'success');
                    } else {
                        log('‚ùå FAILED: Single modal test failed', 'error');
                        updateStatus('Single modal test FAILED', 'error');
                    }
                    
                    updateFlags();
                }, 500);

            } catch (error) {
                log(`‚ùå Error during single modal test: ${error.message}`, 'error');
                updateStatus(`Single modal test error: ${error.message}`, 'error');
            }
        }

        function testConsecutiveModals() {
            if (!gameWindow) {
                updateStatus('Game not loaded! Click "Load Game" first.', 'error');
                return;
            }

            log('üîÑ TESTING CONSECUTIVE MODALS (RACE CONDITION FIX):');
            updateStatus('Testing consecutive modals...', 'info');
            
            testResults = [];
            document.getElementById('test-results').style.display = 'block';
            document.getElementById('results-content').innerHTML = '';

            function runGame(gameNumber, callback) {
                log(`\nüéØ GAME ${gameNumber}:`);
                
                try {
                    // Reset to Ready state
                    gameWindow.gameState = 'Ready';
                    gameWindow.updateUI();
                    log(`   1Ô∏è‚É£ Reset to Ready state (readyStateActive: ${gameWindow.readyStateActive})`);
                    updateFlags();
                    
                    // Set up game conditions with unique score
                    const score = 100 + (gameNumber * 50);
                    gameWindow.gameState = 'Playing';
                    gameWindow.score = score;
                    gameWindow.gameStartTime = Date.now() - 10000;
                    gameWindow.gameWasPlayed = true;
                    gameWindow.scoreSubmitted = false;
                    gameWindow.pageLoadTime = Date.now() - 60000;
                    
                    log(`   2Ô∏è‚É£ Set up playing state with score ${score}`);
                    updateFlags();
                    
                    // End game
                    gameWindow.gameState = 'GameOver';
                    gameWindow.updateUI();
                    log(`   3Ô∏è‚É£ Game ended, updateUI() called`);
                    updateFlags();
                    
                    // Check modal
                    setTimeout(() => {
                        const modal = gameWindow.document.getElementById('nameInputModal');
                        const isVisible = modal && !modal.classList.contains('hide');
                        
                        log(`   üìä GAME ${gameNumber} RESULT: Modal visible = ${isVisible}`);
                        
                        const result = { game: gameNumber, success: isVisible, score: score };
                        testResults.push(result);
                        
                        // Add to results display
                        const resultDiv = document.createElement('div');
                        resultDiv.className = `game-cycle ${isVisible ? 'cycle-success' : 'cycle-failed'}`;
                        resultDiv.innerHTML = `
                            <strong>Game ${gameNumber}:</strong> 
                            ${isVisible ? '‚úÖ SUCCESS' : '‚ùå FAILED'} 
                            (Score: ${score}, Modal: ${isVisible ? 'Visible' : 'Hidden'})
                        `;
                        document.getElementById('results-content').appendChild(resultDiv);
                        
                        if (isVisible) {
                            // Simulate submitting score to reset for next game
                            gameWindow.submitScore(`TestPlayer${gameNumber}`);
                            log(`   ‚úÖ Score submitted for game ${gameNumber}`);
                        }
                        
                        updateFlags();
                        
                        if (callback) callback();
                    }, 500);
                    
                } catch (error) {
                    log(`   ‚ùå Error in game ${gameNumber}: ${error.message}`, 'error');
                    testResults.push({ game: gameNumber, success: false, error: error.message });
                    if (callback) callback();
                }
            }

            // Run 3 consecutive games
            runGame(1, () => {
                setTimeout(() => {
                    runGame(2, () => {
                        setTimeout(() => {
                            runGame(3, () => {
                                // Show final results
                                setTimeout(() => {
                                    log('\nüìä CONSECUTIVE MODAL TEST RESULTS:');
                                    let successCount = 0;
                                    
                                    testResults.forEach(result => {
                                        if (result.success) {
                                            log(`   ‚úÖ Game ${result.game}: SUCCESS (score: ${result.score})`);
                                            successCount++;
                                        } else {
                                            log(`   ‚ùå Game ${result.game}: FAILED (score: ${result.score || 'N/A'})`);
                                            if (result.error) log(`      Error: ${result.error}`);
                                        }
                                    });
                                    
                                    log(`\nüéØ FINAL RESULT: ${successCount}/${testResults.length} games showed modal`);
                                    
                                    if (successCount === testResults.length) {
                                        log('üéâ CONSECUTIVE MODAL FIX SUCCESS! All games showed the modal.', 'success');
                                        updateStatus(`‚úÖ SUCCESS! All ${testResults.length} consecutive games showed the modal.`, 'success');
                                    } else if (successCount === 0) {
                                        log('üí• CONSECUTIVE MODAL FIX FAILED! No games showed the modal.', 'error');
                                        updateStatus(`‚ùå FAILURE! No games showed the modal.`, 'error');
                                    } else {
                                        log(`‚ö†Ô∏è PARTIAL SUCCESS! ${successCount}/${testResults.length} games showed the modal.`, 'warning');
                                        updateStatus(`‚ö†Ô∏è PARTIAL: ${successCount}/${testResults.length} games showed the modal.`, 'warning');
                                    }
                                }, 500);
                            });
                        }, 2000);
                    });
                }, 2000);
            });
        }

        function analyzeRaceCondition() {
            if (!gameWindow) {
                updateStatus('Game not loaded! Click "Load Game" first.', 'error');
                return;
            }

            log('üî¨ ANALYZING RACE CONDITION FIX:');
            updateStatus('Analyzing race condition fix...', 'info');

            try {
                log('üìã Race Condition Analysis:');
                log('‚Ä¢ OLD BEHAVIOR: updateUI() resets flags every time gameState === "Ready"');
                log('‚Ä¢ NEW BEHAVIOR: Flags only reset on FIRST entry to Ready state');
                log('‚Ä¢ FIX: Added readyStateActive flag to track state transitions');
                
                log('\nüîç Current readyStateActive status:');
                log(`‚Ä¢ readyStateActive: ${gameWindow.readyStateActive || false}`);
                
                log('\nüß™ Testing flag reset behavior:');
                
                // Test 1: First entry to Ready state
                gameWindow.gameState = 'Playing';
                gameWindow.readyStateActive = false;
                gameWindow.gameState = 'Ready';
                gameWindow.updateUI();
                log(`‚Ä¢ Test 1 - First Ready entry: readyStateActive = ${gameWindow.readyStateActive}`);
                
                // Test 2: Subsequent updateUI calls while in Ready state
                const beforeFlags = {
                    gameWasPlayed: gameWindow.gameWasPlayed,
                    gameStartTime: gameWindow.gameStartTime,
                    scoreSubmitted: gameWindow.scoreSubmitted
                };
                
                gameWindow.updateUI(); // Should NOT reset flags
                
                const afterFlags = {
                    gameWasPlayed: gameWindow.gameWasPlayed,
                    gameStartTime: gameWindow.gameStartTime,
                    scoreSubmitted: gameWindow.scoreSubmitted
                };
                
                const flagsChanged = JSON.stringify(beforeFlags) !== JSON.stringify(afterFlags);
                log(`‚Ä¢ Test 2 - Subsequent Ready updateUI: Flags changed = ${flagsChanged} (should be false)`);
                
                if (!flagsChanged) {
                    log('‚úÖ RACE CONDITION FIX WORKING: Flags preserved on subsequent updateUI calls', 'success');
                    updateStatus('‚úÖ Race condition fix is working correctly!', 'success');
                } else {
                    log('‚ùå RACE CONDITION FIX FAILED: Flags still being reset', 'error');
                    updateStatus('‚ùå Race condition fix failed - flags still being reset', 'error');
                }
                
                updateFlags();
                
            } catch (error) {
                log(`‚ùå Error during race condition analysis: ${error.message}`, 'error');
                updateStatus(`Analysis error: ${error.message}`, 'error');
            }
        }

        // Initial message
        log('üéØ Consecutive Modal Fix Test Ready');
        log('This test validates the race condition fix for consecutive game modals');
        log('Click "Load Game" to begin testing...');
    </script>
</body>
</html>
